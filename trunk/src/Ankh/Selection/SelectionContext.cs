using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio;
using System.Runtime.InteropServices;
using System.Collections;
using Microsoft.VisualStudio.OLE.Interop;
using IServiceProvider = System.IServiceProvider;

namespace Ankh.Selection
{
	public interface ISelectionContext
	{
		ICollection<string> GetSelectedFiles();
		ICollection<SvnItem> GetSelectedSvnItems();
	}

	/// <summary>
	/// 
	/// </summary>
	class SelectionContext : IVsSelectionEvents, IDisposable, ISelectionContext
	{
		IServiceProvider _environment;
		StatusCache _cache;
		uint _cookie;

		uint _currentItem;
		IVsHierarchy _currentHierarchy;
		IVsMultiItemSelect _currentSelection;
		ISelectionContainer _currentContainer;
		string[] _filenames;
		SvnItem[] _svnItems;

		public SelectionContext(IServiceProvider environment, StatusCache cache)
		{
			if (environment == null)
				throw new ArgumentNullException("environment");
			else if(cache == null)
				throw new ArgumentNullException("cache");

			_environment = environment;
			_cache = cache;

			IVsMonitorSelection monitor = (IVsMonitorSelection)environment.GetService(typeof(IVsMonitorSelection));

			if (monitor != null)
				Marshal.ThrowExceptionForHR(monitor.AdviseSelectionEvents(this, out _cookie));
			else
				_environment = null;
		}

		public void Dispose()
		{
			if (_environment != null)
			{
				IVsMonitorSelection monitor = (IVsMonitorSelection)_environment.GetService(typeof(IVsMonitorSelection));
				_environment = null;

				Marshal.ThrowExceptionForHR(monitor.UnadviseSelectionEvents(_cookie));
			}
		}

		#region IVsSelectionEvents Members

		public int OnCmdUIContextChanged(uint dwCmdUICookie, int fActive)
		{
			/// Some global state change which might change UI cueues
			return VSConstants.S_OK;
		}

		public int OnElementValueChanged(uint elementid, object varValueOld, object varValueNew)
		{
			// Some property changed
			return VSConstants.S_OK;
		}

		public int OnSelectionChanged(IVsHierarchy pHierOld, uint itemidOld, IVsMultiItemSelect pMISOld, ISelectionContainer pSCOld,
				IVsHierarchy pHierNew, uint itemidNew, IVsMultiItemSelect pMISNew, ISelectionContainer pSCNew)
		{
			// The current selection changed; store for future reference
			_currentHierarchy = pHierNew;
			_currentItem = itemidNew;
			_currentSelection = pMISNew;
			_currentContainer = pSCNew;

			ClearCache();

			return VSConstants.S_OK;
		}

		private void ClearCache()
		{
			_filenames = null;
			_svnItems = null;
		}

		#endregion

		protected class SelectionItem
		{
			readonly IVsHierarchy _hierarchy;
			readonly uint _id;

			public SelectionItem(IVsHierarchy hierarchy, uint id)
			{
				_hierarchy = hierarchy;
				_id = id;
			}

			public IVsHierarchy Hierarchy
			{
				get { return _hierarchy; }
			}

			public uint Id
			{
				get { return _id; }
			}
		}

		protected IEnumerable<SelectionItem> GetSelectedItems()
		{
			if (_currentSelection != null)
			{
				uint nItems;
				int withinSingleHierarchy;
				Marshal.ThrowExceptionForHR(_currentSelection.GetSelectionInfo(out nItems, out withinSingleHierarchy));

				uint flags = 0;

				bool singleHierarchy = (withinSingleHierarchy != 0);

				if (singleHierarchy && _currentHierarchy != null)
					flags = (uint)__VSGSIFLAGS.GSI_fOmitHierPtrs; // Don't marshal the hierarchy for every item

				VSITEMSELECTION[] items = new VSITEMSELECTION[nItems];

				Marshal.ThrowExceptionForHR(_currentSelection.GetSelectedItems(flags, nItems, items));

				for (int i = 0; i < nItems; i++)
				{
					yield return new SelectionItem(singleHierarchy ? _currentHierarchy : items[i].pHier, items[i].itemid);
				}
			}
			else if (_currentHierarchy != null)
			{
				yield return new SelectionItem(_currentHierarchy, _currentItem);
			}
		}

		#region ISelectionContext Members

		public ICollection<string> GetSelectedFiles()
		{
			if (_filenames != null)
				return _filenames;

			List<string> filenames = new List<string>();

			// Selection can be generated by several objects. 
			// E.g. the solution provider, a document, our own toolwindows..
			foreach (SelectionItem i in GetSelectedItems())
			{
				IVsSccProject2 p2 = i.Hierarchy as IVsSccProject2;

				if (p2 != null)
				{
					CALPOLESTR[] pathStr = new CALPOLESTR[1];
					CADWORD[] flags = new CADWORD[1];

					int hr = p2.GetSccFiles(i.Id, pathStr, flags);

					if (hr == VSConstants.S_OK)
					{
						foreach (string file in GetFilesFor(p2, i.Id, pathStr, flags))
						{
							filenames.Add(file);
						}
						
					}
					else if (hr == VSConstants.E_NOTIMPL || hr == VSConstants.E_FAIL)
					{
						IVsProject3 p3 = p2 as IVsProject3;

						if (p3 != null)
						{
							string file;
							hr = p3.GetMkDocument(i.Id, out file);

							if (hr == VSConstants.S_OK)
								filenames.Add(file);
						}
					}
					
					Marshal.ThrowExceptionForHR(hr);
				}

			}
			return _filenames = filenames.ToArray();
		}

		public ICollection<SvnItem> GetSelectedSvnItems()
		{
			if(_svnItems != null)
				return _svnItems;

			List<SvnItem> items = new List<SvnItem>();
			foreach (string file in GetSelectedFiles())
			{
				SvnItem i = _cache[file];

				if (i != null)
					items.Add(i);
			}
			return _svnItems = items.ToArray();
		}

		#endregion

		/// <summary>
		/// Gets the files from an OLE String buffer and clears the buffer
		/// </summary>
		/// <param name="pathStr">The path STR.</param>
		/// <returns></returns>
		string[] GetFilesFromOleBuffer(CALPOLESTR[] pathStr)
		{
			int nEls = (int)pathStr[0].cElems;
			string[] files = new string[nEls];
		
			for (int i = 0; i < nEls; i++)
			{
				IntPtr pathIntPtr = Marshal.ReadIntPtr(pathStr[0].pElems, i);
				files[i] = Marshal.PtrToStringUni(pathIntPtr);

				Marshal.FreeCoTaskMem(pathIntPtr);				
			}
			if (pathStr[0].pElems != IntPtr.Zero)
				Marshal.FreeCoTaskMem(pathStr[0].pElems);

			return files;
		}

		private IEnumerable<string> GetFilesFor(IVsSccProject2 p, uint itemId, CALPOLESTR[] pathStr, CADWORD[] flags)
		{
			int n = 0;
			foreach (string file in GetFilesFromOleBuffer(pathStr))
			{
				yield return file;

				if (flags[0].cElems > n)
				{
					int flag = Marshal.ReadInt32(flags[0].pElems, n);

					if (flag != 0)
					{
						CALPOLESTR[] subPathStr = new CALPOLESTR[1];
						CADWORD[] subFlags = new CADWORD[1];

						Marshal.ThrowExceptionForHR(p.GetSccSpecialFiles(itemId, file, subPathStr, subFlags));

						foreach (string fi in GetFilesFor(p, itemId, subPathStr, subFlags))
						{
							yield return fi;
						}
					}
				}
				n++;
			}

			if(flags[0].pElems != IntPtr.Zero)
			{
				Marshal.FreeCoTaskMem(flags[0].pElems);
			}
		}
	}
}